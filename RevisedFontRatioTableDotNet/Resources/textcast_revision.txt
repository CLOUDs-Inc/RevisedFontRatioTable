// --------------------------------------------------------------------------------------------------------------------
// Module for checking text cast width generated by plugin
// --------------------------------------------------------------------------------------------------------------------
##CPP-HEADER
#include "stdio.h"
#include "FrameworkBuildOption.h"

#include "../../../MXEOne/Platform/OpenGL/Text/MXEOne_Platform_Render_Text_Control.h"
#include "../../../MXEOne/Include/MXEOne_Platform_Utils.h"

#define DELTA(a,b) ((a) >= (b) ? (a)-(b) : (b)-(a))

enum {
	TRR_LANG_ENG = 0,
	TRR_LANG_GER = 1,
	TRR_LANG_FRE = 2,
	TRR_LANG_SPA = 3,
	TRR_LANG_ITA = 4,
	TRR_LANG_POR = 5,
	TRR_LANG_RUS = 6,
	TRR_LANG_UKR = 7,
	TRR_LANG_TUR = 8,
	TRR_LANG_ARA = 9,
	TRR_LANG_THA = 10,
	TRR_LANG_MAX
};

typedef struct _RatioRevisionData {
	mx_int32 textCastNumber;
	mx_float32 textFontRate;
	const char *textCastName;
	mx_int32 nonMultiLangFlag;
} RatioRevisionData;

#define TRR_DATA_TABLE_SIZE ([TABLE_SIZE])

extern const RatioRevisionData [TABLE_NAME][];

void WriteRatioRevisionLog();

// --------------------------------------------------------------------------------------------------------------------

// --------------------------------------------------------------------------------------------------------------------
##CPP-SRC

#include "Util.h"
#include<string>

#ifdef __cplusplus
extern
#endif
const RatioRevisionData [TABLE_NAME][TRR_DATA_TABLE_SIZE] = {
[TEXTCAST_REVISION_DATA]
};


mx_bool revRatioLimitCheck(mx_bool makingWider, mx_float32 revRatio)
{
	return (makingWider == true) ? (revRatio <= 1.1f) : (0.75f <= revRatio);
}

mx_bool CheckBigDiff(int width_ideal, int width_revised)
{
	int absDiff = DELTA(width_ideal, width_revised);

	int diffAdmit = (int)(width_ideal * 0.02f);
	/* omit case that diffAdmit is zero */
	diffAdmit = (diffAdmit < 2) ? 2 : diffAdmit;

	return (diffAdmit < absDiff) ? true : false;
}

int GetWidthOfLines(mx_sint32 textCastNumber, mx_sint32 nonMultiLangFlag){
	int lineCount = 0;
	int maxWidth = 0;

	/* Get line count of target text cast */
	lineCount = TextCast::Lines::GetCount(textCastNumber);

	if(nonMultiLangFlag == 0){
		/* Check text cast width of each line */
		for(int lineIndex = 0; lineIndex < lineCount; ++lineIndex){
			int targetWidth = TextCast::Lines::GetWidth(textCastNumber, lineIndex);
			/* pick up wider width */
			if(maxWidth < targetWidth){
				maxWidth = targetWidth;
			}
		}
	}
	else{
		/* Check text cast width of each line */
		for(int lineIndex = 0; lineIndex < lineCount; ++lineIndex)
		{
			mx_char16 *pOrigStr = (mx_char16 *)NULL;

			TextCast::Lines::GetROMPtrU16(textCastNumber, lineIndex, &pOrigStr, 0);
			int targetWidth = TextCast::GetStringWidthU16(textCastNumber, pOrigStr);

			/* pick up wider width */
			if(maxWidth < targetWidth){
				maxWidth = targetWidth;
			}
		}
	}

	return maxWidth;
}

mx_float32 ReviseRatio(void* pMxeWorkMemory, char* pLogLine, RatioRevisionData* pData, int langID){
	mx_float32 resultRatio = -1.0f;

	mx_sint32 textCastNumber = pData->textCastNumber;
	mx_float32 ratio = pData->textFontRate;
	mx_sint32 nonMultiLangFlag = pData->nonMultiLangFlag;
	int lineCount = 0;
	int maxWidth = 0;

	/* set glyph scale to ratio 1.0 */
	MXEOne_Text_SetGlyphScaleH(pMxeWorkMemory, textCastNumber, 1.0F);

	/* actual width in ratio 1.0 */
	int width_1_0 = GetWidthOfLines(textCastNumber, nonMultiLangFlag);
	/* assumed width */
	const int width_ideal = (int)(width_1_0 * ratio);

	/* set glyph scale to ratio designated */
	MXEOne_Text_SetGlyphScaleH(pMxeWorkMemory, textCastNumber, ratio);
	/* actual width in ratio designated */
	int width_actual = GetWidthOfLines(textCastNumber, nonMultiLangFlag);
	int width_revised = width_actual;
	int width_prev;

	mx_bool revFin = false;
	//int deltaPrev;
	//int deltaNow = DELTA(width_actual, width_ideal);
	mx_bool makingWider = false;
	mx_float32 shiftRatio;

	/* compare ideal and actual width */
	if(width_ideal < width_revised)
	{
		makingWider = false;
		shiftRatio = -0.01f;
	}
	else{
		/* ideal and actual width are matched */
		resultRatio = ratio;
		
		/* print log format into text buffer */
		sprintf(
			pLogLine,
			"Lang:%d, CastNo:%d[%s], Ideal[ratio:%.2f, width:%d], Actual[width:%d], nonMLFlag[%d]",
			langID,
			pData->textCastNumber,
			pData->textCastName,
			pData->textFontRate,
			width_ideal,
			width_revised,
			nonMultiLangFlag
		);
		return resultRatio;
	}


	/* to check ratio shift count */
	int shiftCount = 0;

	/* compare ideal and actual width */
	/* actual is narrow, so making wider CASE*/
	for(mx_float32 revRatio = ratio + shiftRatio; revRatioLimitCheck(makingWider, revRatio) && !revFin ; revRatio += shiftRatio)
	{
		++shiftCount;
		/* keep previous width for overshooting at this time of loop */
		width_prev = width_revised;

		/* set glyph scale to ratio revised */
		MXEOne_Text_SetGlyphScaleH(pMxeWorkMemory, textCastNumber, revRatio);
		/* actual width in ratio designated */
		width_revised = GetWidthOfLines(textCastNumber, nonMultiLangFlag);

		/* To judge the nearest width, making up ratio or making down ratio */

		/* compare ideal and revised width (MATCH) */
		if(width_ideal == width_revised)
		{
			/* revised ratio is good */
			resultRatio = revRatio;
			revFin = true;
		}
		/* compare ideal and revised width (Overshoot) */
		else if((makingWider == true) ? (width_ideal < width_revised) : (width_revised < width_ideal)){
			/* making wider/more narrow overshoot */

			if(makingWider == true){
				/* widen overshoot CASE: previous ratio is good */
				resultRatio = revRatio - shiftRatio;
				/* previous width is good */
				width_revised = width_prev;
			}
			else{
				/* making narrow overshot CASE: Present ratio is good */
				resultRatio = revRatio;
			}
			revFin = true;
		}
		/* compare ideal and revised width (Not Enough) */
		else if((makingWider == true) ? (width_revised < width_ideal) : (width_ideal < width_revised)){
			/* making wider/more narrow is not enough */
		}
	}


	mx_bool bigDiffWarn = CheckBigDiff(width_ideal, width_revised);

	/* print log format into text buffer */
	sprintf(
		pLogLine,
		"Lang:%d, CastNo:%d[%s], Ideal[ratio:%.2f, width:%d], Actual[width:%d], nonMLFlag[%d], Revised[ratio:%.2f, width:%d]%s%s",
		langID,
		pData->textCastNumber,
		pData->textCastName,
		pData->textFontRate,
		width_ideal,
		width_actual,
		nonMultiLangFlag,
		resultRatio,
		width_revised,
		(bigDiffWarn ? "[WARN_DIFF]" : ""),
		((3 < shiftCount) ? "[WARN_RATIO]" : "")
	);

	return resultRatio;
}

std::string GetTextCastStringRev(mx_sint32 textCastNumber) {
	std::string resultString = "";
	mx_bool apiResult = false;
	int lineCount = 0;

	/* Get line count of target text cast */
	lineCount = TextCast::Lines::GetCount(textCastNumber);

	/* Check text cast string */
	for (int lineIndex = 0; lineIndex < lineCount; ++lineIndex) {
		mx_char16* pChar16Str = nullptr;
		apiResult = TextCast::Lines::GetStrPtrU16(textCastNumber, lineIndex, &pChar16Str);
		if (apiResult)
		{
			char *pStrValue = Char16ToChar(pChar16Str);
			if (lineIndex == 0) {
				resultString = std::string("str=") + std::string(pStrValue);
			}
			else {
				resultString = resultString + std::string("[CR]") + std::string(pStrValue);
			}
			MXFree(pStrValue);
		}
	}

	return resultString;
}

mx_float32 revisedRatioArray[TRR_DATA_TABLE_SIZE][TRR_LANG_MAX];

void WriteRatioRevisionLog(){
	int indexID;
	int langID;
	int prevLangID;
	FILE *fpLog = NULL;
	FILE *fpTableCode = NULL;
	void *pMxeWorkMemory = NULL;
	const char *TRR_LOG_START_LINE = "<== TEXT CAST RATIO REVISION RESULT LOG BEGIN";
	const char *TRR_LOG_END_LINE = "==> TEXT CAST RATIO REVISION RESULT LOG END";
#ifdef _WIN32
	const char *TRR_LOG_FILENAME = "textcast_ratio_revision.log";
	const char *TRR_TABLE_CODE = "FontRateTable.s.txt";
#else
	const char *TRR_LOG_FILENAME = "/home/root/textcast_ratio_revision.log";
	const char *TRR_TABLE_CODE = "/home/root/FontRateTable.s.txt";
#endif
	const char *TRR_SCRIPT_PREFIX = 
		"// --------------------------------------------------------------------------------------------------------------------\n"
		"// Font Scale Table generated by plugin\n"
		"// --------------------------------------------------------------------------------------------------------------------\n"
		"##CPP-HEADER\n"
		"\n"
		"#define TFR_DATA_TABLE_SIZE_MULTI ([TABLE_SIZE])\n"
		"\n"
		"extern const mx_float32 gTextFontScaleArrayMultiXInch[]\n"
		"\n"
		"// --------------------------------------------------------------------------------------------------------------------\n"
		"\n"
		"// --------------------------------------------------------------------------------------------------------------------\n"
		"##CPP-SRC\n"
		"\n"
		"#ifdef __cplusplus\n"
		"extern\n"
		"#endif\n";

	const char *TRR_TABLE_START_LINE = "const mx_float32 gTextFontScaleArrayMultiXInch[] = {";
	const char *TRR_TABLE_END_LINE = "};";

	prevLangID = SystemInfo::GetLanguage();
	pMxeWorkMemory = MXEOne_PlatformUtil_GetCurrentWorkMem();

	LOG(TRR_LOG_START_LINE);
	DLOG(TRR_LOG_START_LINE);
	fpLog = fopen(TRR_LOG_FILENAME, "w");
	fpTableCode = fopen(TRR_TABLE_CODE, "w");

	if(fpLog != NULL && fpTableCode != NULL){
		mx_bool bLangChange = false;

		fwrite(TRR_LOG_START_LINE, sizeof(char), strlen(TRR_LOG_START_LINE), fpLog);
		fputc('\n', fpLog);

		fwrite(TRR_SCRIPT_PREFIX, sizeof(char), strlen(TRR_SCRIPT_PREFIX), fpTableCode);
		fwrite(TRR_TABLE_START_LINE, sizeof(char), strlen(TRR_TABLE_START_LINE), fpTableCode);
		fputc('\n', fpTableCode);

		for (int index = 0; index < TRR_DATA_TABLE_SIZE; ++index) {
			for (langID = 0; langID < TRR_LANG_MAX; ++langID) {
				revisedRatioArray[index][langID] = -1.0F;
			}
		}

		for (langID = 0; langID < TRR_LANG_MAX; ++langID)
		{
			bLangChange = SystemInfo::SetLanguage(langID);
			if(bLangChange == true){
				for(indexID = 0; indexID < TRR_DATA_TABLE_SIZE; ++indexID)
				{
					RatioRevisionData *pData = (RatioRevisionData*)&([TABLE_NAME][indexID]);

					char pLogLine[512] = {0};
					//char pCodeLine[512] = { 0 };

					if(0.0F < pData->textFontRate)
					{
						/* calc revised ratio and its log string */
						mx_float32 revisedRatio = ReviseRatio(pMxeWorkMemory, pLogLine, pData, langID);
						revisedRatioArray[indexID][langID] = revisedRatio;

						/* get text of text cast */
						//std::string textCastString = GetTextCastStringRev(pData->textCastNumber);

						/* create revised ratio values table */
						//sprintf(pCodeLine, "\t%.2fF, /* cnum = %d %s %s */", revisedRatio, pData->textCastNumber, pData->textCastName, textCastString.c_str());
					}
					else
					{
						/* create log string that text cast unused */
						sprintf(pLogLine, "Lang:%d, CastNo:%d Not Used", langID, indexID);

						/* create revised ratio values table: -1.0f */
						//sprintf(pCodeLine, "\t%.2fF, /* cnum = %d */", -1.0F, indexID);
					}

					/* LOG(pLogLine); */
					fwrite(pLogLine, sizeof(char), strlen(pLogLine), fpLog);
					fputc('\n', fpLog);
				}
			}
			else{
				/* Lang Change Failed */
				/* do nothing */
			}
		}
		fwrite(TRR_LOG_END_LINE, sizeof(char), strlen(TRR_LOG_END_LINE), fpLog);
		fputc('\n', fpLog);

		SystemInfo::SetLanguage(0);

		for (indexID = 0; indexID < TRR_DATA_TABLE_SIZE; ++indexID)
		{
			RatioRevisionData* pData = (RatioRevisionData*)&(gTextRatioRevDataArray[indexID]);
			mx_float32 minRatio = 100.0f;

			/* get text of text cast */
			std::string textCastString = GetTextCastStringRev(pData->textCastNumber);

			
			for (langID = 0; langID < TRR_LANG_MAX; ++langID) {
				if (0.0f < revisedRatioArray[indexID][langID]) {
					if (revisedRatioArray[indexID][langID] < minRatio) {
						minRatio = revisedRatioArray[indexID][langID];
					}
				}
			}
			
			char pCodeLine[1024] = { 0 };
			if (0.0f < pData->textFontRate) {
				/* create revised ratio values table */
				sprintf(pCodeLine, "\t%.2fF, /* cnum=%d [%.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f] %s %s */",
					minRatio, pData->textCastNumber,
					revisedRatioArray[indexID][TRR_LANG_ENG],
					revisedRatioArray[indexID][TRR_LANG_GER],
					revisedRatioArray[indexID][TRR_LANG_FRE],
					revisedRatioArray[indexID][TRR_LANG_SPA],
					revisedRatioArray[indexID][TRR_LANG_ITA],
					revisedRatioArray[indexID][TRR_LANG_POR],
					revisedRatioArray[indexID][TRR_LANG_RUS],
					revisedRatioArray[indexID][TRR_LANG_UKR],
					revisedRatioArray[indexID][TRR_LANG_TUR],
					revisedRatioArray[indexID][TRR_LANG_ARA],
					revisedRatioArray[indexID][TRR_LANG_THA],
					pData->textCastName, textCastString.c_str());
			}
			else {
				/* create revised ratio values table: -1.0f */
				sprintf(pCodeLine, "\t%.2fF, /* cnum = %d */", -1.0F, indexID);
			}

			/* write revised ratio table data */
			fwrite(pCodeLine, sizeof(char), strlen(pCodeLine), fpTableCode);
			fputc('\n', fpTableCode);
		}

		fwrite(TRR_TABLE_END_LINE, sizeof(char), strlen(TRR_TABLE_END_LINE), fpTableCode);
		fputc('\n', fpTableCode);
	}

	if(fpLog != NULL){
		fflush(fpLog);
		fclose(fpLog);
	}
	if(fpTableCode != NULL){
		fflush(fpTableCode);
		fclose(fpTableCode);
	}

	LOG(TRR_LOG_END_LINE);
	DLOG(TRR_LOG_END_LINE);
	SystemInfo::SetLanguage(prevLangID);
}

